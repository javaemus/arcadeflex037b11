/**
 * ported to 037b11
 */
package mame037b11;


import static arcadeflex.fucPtr.InterruptPtr;


public class cpuintrfH {
    public static class MachineCPU {
        public MachineCPU(int ct, int cc, Object[] mr, Object[] mw, Object[] pr, Object[] pw, InterruptPtr vb, int vbf, InterruptPtr ti, int tif, Object reset) {
            cpu_type = ct;
            cpu_clock = cc;
            memory_read = mr;
            memory_write = mw;
            port_read = pr;
            port_write = pw;
            vblank_interrupt = vb;
            vblank_interrupts_per_frame = vbf;
            timed_interrupt = ti;
            timed_interrupts_per_second = tif;
            reset_param = reset;
        }

        public MachineCPU(int ct, int cc, Object[] mr, Object[] mw, Object[] pr, Object[] pw, InterruptPtr vb, int vbf, InterruptPtr ti, int tif) {
            this(ct, cc, mr, mw, pr, pw, vb, vbf, ti, tif, null);
        }

        public MachineCPU(int ct, int cc, Object[] mr, Object[] mw, Object[] pr, Object[] pw, InterruptPtr vb, int vbf) {
            //3 last parameter are null
            this(ct, cc, mr, mw, pr, pw, vb, vbf, null, 0, null);
        }

        public MachineCPU() {
            this(0, 0, null, null, null, null, null, 0, null, 0, null);
        }

        public static MachineCPU[] create(int n) {
            MachineCPU[] a = new MachineCPU[n];
            for (int k = 0; k < n; k++)
                a[k] = new MachineCPU();
            return a;
        }

        public int cpu_type;	/* see #defines below. */
        public int cpu_clock;	/* in Hertz */
        public Object[] memory_read;
        public Object[] memory_write;
        public Object[] port_read;
        public Object[] port_write;
        public InterruptPtr vblank_interrupt;
        int vblank_interrupts_per_frame;    /* usually 1 */
        /* use this for interrupts which are not tied to vblank 	*/
                /* usually frequency in Hz, but if you need 				*/
                /* greater precision you can give the period in nanoseconds */
        public InterruptPtr timed_interrupt;
        int timed_interrupts_per_second;
        /* pointer to a parameter to pass to the CPU cores reset function */
        public Object reset_param;

    }

    /* the following list is automatically generated by makelist.pl - don't edit manually! */
    public static final int CPU_DUMMY = 0;
    public static final int CPU_Z80 = 1;
    public static final int CPU_SH2 = 2;
    public static final int CPU_8080 = 3;
    public static final int CPU_8085A = 4;
    public static final int CPU_M6502 = 5;
    public static final int CPU_M65C02 = 6;
    public static final int CPU_M6510 = 7;
    public static final int CPU_N2A03 = 8;
    public static final int CPU_H6280 = 9;
    public static final int CPU_I86 = 10;
    public static final int CPU_I186 = 11;
    public static final int CPU_V20 = 12;
    public static final int CPU_V33 = 13;
    public static final int CPU_I8035 = 14;
    public static final int CPU_I8039 = 15;
    public static final int CPU_I8048 = 16;
    public static final int CPU_N7751 = 17;
    public static final int CPU_M6800 = 18;
    public static final int CPU_M6801 = 19;
    public static final int CPU_M6802 = 20;
    public static final int CPU_M6803 = 21;
    public static final int CPU_M6808 = 22;
    public static final int CPU_HD63701 = 23;
    public static final int CPU_NSC8105 = 24;
    public static final int CPU_M6805 = 25;
    public static final int CPU_M68705 = 26;
    public static final int CPU_HD63705 = 27;
    public static final int CPU_HD6309 = 28;
    public static final int CPU_M6809 = 29;
    public static final int CPU_KONAMI = 30;
    public static final int CPU_M68000 = 31;
    public static final int CPU_M68010 = 32;
    public static final int CPU_M68EC020 = 33;
    public static final int CPU_M68020 = 34;
    public static final int CPU_T11 = 35;
    public static final int CPU_S2650 = 36;
    public static final int CPU_TMS34010 = 37;
    public static final int CPU_TMS9980 = 38;
    public static final int CPU_Z8000 = 39;
    public static final int CPU_TMS320C10 = 40;
    public static final int CPU_CCPU = 41;
    public static final int CPU_ADSP2100 = 42;
    public static final int CPU_ADSP2105 = 43;
    public static final int CPU_PSXCPU = 44;
    public static final int CPU_ASAP = 45;
    public static final int CPU_COUNT = 46;

    /* set this if the CPU is used as a slave for audio. It will not be emulated if */
    /* sound is disabled, therefore speeding up a lot the emulation. */
    public static final int CPU_AUDIO_CPU = 0x8000;

    /* the Z80 can be wired to use 16 bit addressing for I/O ports */
    public static final int CPU_16BIT_PORT = 0x4000;

    public static final int CPU_FLAGS_MASK = 0xff00;


    /* The old system is obsolete and no longer supported by the core */
    public static final int NEW_INTERRUPT_SYSTEM = 1;

    public static final int MAX_IRQ_LINES = 8;       /* maximum number of IRQ lines per CPU */

    public static final int CLEAR_LINE = 0;		/* clear (a fired, held or pulsed) line */
    public static final int ASSERT_LINE = 1;       /* assert an interrupt immediately */
    public static final int HOLD_LINE = 2;       /* hold interrupt line until enable is true */
    public static final int PULSE_LINE = 3;		/* pulse interrupt line for one instruction */

    public static final int MAX_REGS = 128; 	/* maximum number of register of any CPU */

    /* Values passed to the cpu_info function of a core to retrieve information */
    public static final int CPU_INFO_REG = 0;
    public static final int CPU_INFO_FLAGS = MAX_REGS;
    public static final int CPU_INFO_NAME = MAX_REGS + 1;
    public static final int CPU_INFO_FAMILY = MAX_REGS + 2;
    public static final int CPU_INFO_VERSION = MAX_REGS + 3;
    public static final int CPU_INFO_FILE = MAX_REGS + 4;
    public static final int CPU_INFO_CREDITS = MAX_REGS + 5;
    public static final int CPU_INFO_REG_LAYOUT = MAX_REGS + 6;
    public static final int CPU_INFO_WIN_LAYOUT = MAX_REGS + 7;

    public static final int CPU_IS_LE = 0;	/* emulated CPU is little endian */
    public static final int CPU_IS_BE = 1; /* emulated CPU is big endian */

    /*
     * This value is passed to cpu_get_reg to retrieve the previous
     * program counter value, ie. before a CPU emulation started
     * to fetch opcodes and arguments for the current instrution.
     */
    public static final int REG_PREVIOUSPC = -1;

    /*
     * This value is passed to cpu_get_reg/cpu_set_reg, instead of one of
     * the names from the enum a CPU core defines for it's registers,
     * to get or set the contents of the memory pointed to by a stack pointer.
     * You can specify the n'th element on the stack by (REG_SP_CONTENTS-n),
     * ie. lower negative values. The actual element size (UINT16 or UINT32)
     * depends on the CPU core.
     * This is also used to replace the cpu_geturnpc() function.
     */
    public static final int REG_SP_CONTENTS = -2;


    public static abstract interface burnPtr {
        public abstract void handler(int cycles);
    }

    public static abstract interface irqcallbacksPtr {
        public abstract int handler(int irqline);
    }

    /* ASG 971222 -- added this generic structure */
    public static abstract class cpu_interface {
        public int cpu_num;

        public abstract void reset(Object param);

        public abstract void exit();

        public abstract int execute(int cycles);

        public burnPtr burn;

        public abstract Object init_context(); //not in mame , used specific for arcadeflex

        public abstract Object get_context(); //different from mame returns reg object and not size since java doesn't support references

        public abstract void set_context(Object reg);

        /*TODO*///        void*( * get_cycle_table)( int which);
/*TODO*///        void( * set_cycle_table)( int which,void*new_table);
        public abstract int get_pc();

        public abstract void set_pc(int val);

        public abstract int get_sp();

        public abstract void set_sp(int val);

        public abstract int get_reg(int regnum);

        public abstract void set_reg(int regnum, int val);

        public abstract void set_nmi_line(int linestate);

        public abstract void set_irq_line(int irqline, int linestate);

        public abstract void set_irq_callback(irqcallbacksPtr callback);

        public abstract void internal_interrupt(int type);

        public abstract void cpu_state_save(Object file);

        public abstract void cpu_state_load(Object file);

        public abstract String cpu_info(Object context, int regnum);

        /*TODO*///       unsigned (*cpu_dasm)(char *buffer,unsigned pc); //probably doesn't need to support that (shadow)
        public int num_irqs;
        public int default_vector;
        public int[] icount;
        public double overclock;
        public int no_int, irq_int, nmi_int;
        public int databus_width;
        /*TODO*///         mem_read_handler memory_read;
/*TODO*///         mem_write_handler memory_write;
/*TODO*///         mem_read_handler internal_read;
/*TODO*///         mem_write_handler internal_write;
        public int pgm_memory_base;

        public abstract void set_op_base(int pc);

        public int address_shift;
        public int address_bits, endianess, align_unit, max_inst_len;
    }


/* Returns previous pc (start of opcode causing read/write) */
/* int cpu_getpreviouspc(void); */
/*TODO*///     #define cpu_getpreviouspc() cpu_get_reg(REG_PREVIOUSPC)

/* Returns the return address from the top of the stack (Z80 only) */
/* int cpu_getreturnpc(void); */
/* This can now be handled with a generic function */
/*TODO*///             #define cpu_geturnpc() cpu_get_reg(REG_SP_CONTENTS)


    /* daisy-chain link */
    public static class Z80_DaisyChain {
        /*TODO*///       void (*reset)(int);             /* reset callback     */
/*TODO*///         int  (*interrupt_entry)(int);   /* entry callback     */
/*TODO*///         void (*interrupt_reti)(int);    /* reti callback      */
        int irq_param;                  /* callback paramater */
    }

    public static final int Z80_MAXDAISY = 4;		/* maximum of daisy chan device */

    public static final int Z80_INT_REQ = 0x01;   /* interrupt request mask       */
    public static final int Z80_INT_IEO = 0x02;    /* interrupt disable mask(IEO)  */

/*TODO*///     #define Z80_VECTOR(device,state) (((device)<<8)|(state))


}
